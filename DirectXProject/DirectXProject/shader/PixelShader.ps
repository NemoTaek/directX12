Texture2D shaderTexture;	// 텍스쳐 자원으로써 모델에 텍스쳐를 그릴 때 사용한다.
SamplerState SampleType;	// 텍스쳐 자원에서 표본을 추출할 때 어떤 필터링 방식과 좌표 지정모드를 적용할 것인지를 표본추출기로 지정한다.

cbuffer LightBuffer
{
	float4 ambientColor;	// 주변광
	float4 diffuseColor;	// 분산조명
	float3 lightDirection;	// 빛 방향
	// float specularPower;	// 반사 강도
	// float4 specularColor;	// 반영광 색
};

struct PixelInputType
{
	float4 position : SV_POSITION;
	float4 color : COLOR;
	// float2 tex : TEXCOORD0;
	// float3 normal : NORMAL;
	// float3 viewDirection : TEXCOORD1;
};

float4 TessellationPixelShader(PixelInputType input) : SV_TARGET
{
	return input.color;


	/*
	// 조명 설정
	float4 textureColor;
	float3 lightDir;		// 시야 방향
	float lightIntensity;	// 조명값
	float4 color;
	float3 reflection;		// 반사벡터
	float4 specular;		// 반영광

	// 이 텍스쳐 좌표 위치에서 샘플러를 사용하여 텍스쳐에서 픽셀 색상을 샘플링
	textureColor = shaderTexture.Sample(SampleType, input.tex);

	// 기본 출력 색을 주변광으로 설정
	color = ambientColor;

	// 반영광 색 초기화
	// specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// 빛 벡터는 입사광 진행방향과 반대이다
	lightDir = -lightDirection;

	// 픽셀의 빛의 양 계산
	// saturate(x): 주어진 인수를 [0, 1] 구간으로 한정하는 함수
	lightIntensity = saturate(dot(input.normal, lightDir));

	// 법선벡터와 빛벡터의 내적이 0보다 클 때
	if(lightIntensity > 0.0f) {
		// 조명값을 주변광에 더해줌
		color += (diffuseColor * lightIntensity);
		color = saturate(color);

		// 조명값, 법선벡터, 시야 방향을 기준으로 반사벡터 계산
		reflection = normalize(2 * lightIntensity * input.normal - lightDir);

		// 반사벡터, 시야 방향, 반사 강도를 기준으로 반영광 계산
		specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower);
	}

	// 최종 빛 색상 설정
	color = color * textureColor;

	// 정반사 효과 적용, 이로 인해 더욱 입체적이게 될 것
	color = saturate(color + specular);

	if(lightIntensity > 0.0f) {
		color += (diffuseColor * lightIntensity);
	}
	color = saturate(color);
	color = color * textureColor;

	return color;

	// 알파블렌딩
	float4 textureColor1;
	float4 textureColor2;
	float4 blendColor;	// 2개 텍스쳐 혼합한 텍스쳐
	float4 lightTexture;	// 좁은 시야를 나타낼 때 사용하는 텍스쳐
	float4 alphaValue;	// 알파 블렌딩 값
	float4 alphaBlendColor;		// 알파 블렌딩 한 색

	// 이 텍스쳐 좌표 위치에서 샘플러를 사용하여 텍스쳐에서 픽셀 색상을 샘플링 한다.
	textureColor1 = shaderTextures[0].Sample(SampleType, input.tex);
	textureColor2 = shaderTextures[1].Sample(SampleType, input.tex);

	// 알파 블렌딩 전용
	alphaValue = shaderTextures[2].Sample(SampleType, input.tex);

	// 다중 텍스쳐 혼합용 계산
	blendColor = basePixel * colorPixel * gammaCorrection
	// 두 픽셀 값을 혼합 후 감마(여기서는 2.0)을 곱한다.
	blendColor = textureColor1 * textureColor2 * 2.0f;
	blendColor = saturate(blendColor);

	// 좁은 시야용 텍스쳐는 그냥 혼합만 한다.
	// 여기에도 감마값을 곱하면 강하거나 부드러운 광원 효과를 얻을 수 있다.
	lightTexture = textureColor1 * textureColor2 * 2.0f;

	// 알파 블렌딩 계산
	alphaBlendColor = (alphaValue * textureColor1) + ((1.0f - alphaValue) * textureColor2);
	alphaBlendColor = saturate(alphaBlendColor);

	return alphaBlendColor;
	*/
}