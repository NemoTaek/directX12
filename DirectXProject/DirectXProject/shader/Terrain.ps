// Texture2D shaderTexture : register(t0);
// Texture2D detailTexture : register(t1);	// 디테일 맵

// Texture2D flatTexture : register(t0);	// 평지
// Texture2D slopeTexture : register(t1);	// 완만한 경사
// Texture2D scarpTexture : register(t2);	// 급경사

Texture2D colorTexture1 : register(t0);
Texture2D colorTexture2 : register(t1);
Texture2D colorTexture3 : register(t2);
Texture2D colorTexture4 : register(t3);
Texture2D alphaTexture : register(t4);
Texture2D normalMap1 : register(t5);
Texture2D normalMap2 : register(t6);

SamplerState SampleType;

cbuffer LightBuffer
{
	// float4 lightDiffuseColor;
	float3 lightDirection;
	// float colorTextureBrightness;
	float padding;
}

cbuffer TextureInfoBuffer
{
	bool useAlpha;
	float3 padding2;
}

struct PixelInputType
{
	float4 position : SV_POSITION;
	float2 tex : TEXCOORD0;
   	float3 normal : NORMAL;
	float3 tangent : TANGENT;
	float3 binormal : BINORMAL;
	// float4 color : COLOR;
	// float4 depthPosition: TEXCOORD1;	// 근접한 텍스처를 볼 때 선명하게 보이도록 픽셀의 깊이 변수 추가
	float2 tex2 : TEXCOORD1;
};

float4 TerrainPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor1;
	float4 textureColor2;
	float4 textureColor3;
	float4 textureColor4;
	float3 lightDir;
	float lightIntensity1;
	float lightIntensity2;
	float4 color;

	float4 bumpMap;
    float3 bumpNormal;
	float4 alphaMap;
	float4 baseColor;

	// 빛 방향은 실제와 반대방향
	lightDir = -lightDirection;

	// 법선 맵을 사용하여 범프 맵을 계산
	bumpMap = normalMap1.Sample(SampleType, input.tex);
	bumpMap = (bumpMap * 2.0f) - 1.0f;
	bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
	bumpNormal = normalize(bumpNormal);
    lightIntensity1 = saturate(dot(bumpNormal, lightDir));

	bumpMap = normalMap2.Sample(SampleType, input.tex);
	bumpMap = (bumpMap * 2.0f) - 1.0f;
	bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
	bumpNormal = normalize(bumpNormal);
    lightIntensity2 = saturate(dot(bumpNormal, lightDir));

	// 색상 텍스처를 샘플링하고, 각각의 텍스처에 범프맵 추가
	textureColor1 = colorTexture1.Sample(SampleType, input.tex);
	textureColor1 = saturate(lightIntensity1 * textureColor1);
	textureColor2 = colorTexture2.Sample(SampleType, input.tex);
	textureColor2 = saturate(lightIntensity1 * textureColor2);
	textureColor3 = colorTexture3.Sample(SampleType, input.tex);
	textureColor3 = saturate(lightIntensity1 * textureColor3);
	textureColor4 = colorTexture4.Sample(SampleType, input.tex);
	textureColor4 = saturate(lightIntensity2 * textureColor4);

	alphaMap = alphaTexture.Sample(SampleType, input.tex2);

	// 기본 색상 설정
	baseColor = textureColor1;

	// 알파맵의 r, g, b를 사용하여 레이어 추가
	color = lerp(baseColor, textureColor2, alphaMap.r);
	color = lerp(color, textureColor3, alphaMap.g);
	color = lerp(color, textureColor4, alphaMap.b);

    return color;


	/*
	// 기울기 텍스처
	float4 flatColor;
	float4 slopeColor;
	float4 scarpColor;
	float slope;
	float blendAmount;

	flatColor = flatTexture.Sample(SampleType, input.tex);
	slopeColor = slopeTexture.Sample(SampleType, input.tex);
	scarpColor = scarpTexture.Sample(SampleType, input.tex);

	// 기울기 계산
	slope = 1.0f - input.normal.y;

	// 높이에 따라 사용할 텍스처 결정
	if(slope < 0.2) {
		blendAmount = slope / 0.2f;
		textureColor = lerp(flatColor, slopeColor, blendAmount);
	} else if(slope >= 0.2 && slope < 0.7) {
		blendAmount = (slope - 0.2f) * (1.0f / (0.7f - 0.2f));
		textureColor = lerp(slopeColor, scarpColor, blendAmount);
	} else if (slope >= 0.7) {
		textureColor = scarpColor;
	}

	// 빛 방향은 실제와 반대방향
	lightDir = -lightDirection;

	// 현재 픽셀의 빛의 양 계산
	lightIntensity = saturate(dot(input.normal, lightDir));
	if(lightIntensity > 0.0f) {
		color = (diffuseColor * lightIntensity);
	}
	color = saturate(color);
	
	// 텍스처 픽셀과 빛을 곱하여 색상 계산
	color = color * textureColor;

	// 컬러 맵 값을 조합하여 최종 색상 계산
	// color = saturate(color * input.color * 2.0f);

	return color;
	*/


	// 지형 블렌딩
	/*
	float4 textureColor2;
	float4 alphaValue;
	float4 blendColor;

	if(useAlpha) {
		textureColor1 = shaderTexture1.Sample(SampleType, input.tex);
		textureColor2 = shaderTexture2.Sample(SampleType, input.tex);

		// 알파 블렌딩 값 샘플링
		alphaValue = alphaMap.Sample(SampleType, input.tex);

		// 알파 값을 계산하여 블렌딩 색상 계산
		blendColor = (alphaValue * textureColor2) + ((1.0 - alphaValue) * textureColor1);
	} else {
		// 알파 블렌딩을 적용 안한다면 일반 텍스처로 색상 사용
		blendColor = shaderTexture1.Sample(SampleType, input.tex);
	}
	*/


	// 디테일 맵
	/*
	float depthValue;
	float detailBrightness;
	float4 detailColor;

	textureColor = shaderTexture.Sample(SampleType, input.tex.xy);

	// Z 픽셀 깊이를 균질 W 좌표로 나누어 픽셀의 깊이 값 세팅
	depthValue = input.depthPosition.z / input.depthPosition.w;

	// 깊이 값이 화면에 가까운지 체크하고, 근접하다면 디테일 텍스처 적용
	if(depthValue < 0.9f) {
		detailColor = detailTexture.Sample(SampleType, input.tex.zw);

		// 디테일 텍스처 밝기 설정
		detailBrightness = 1.8f;

		// 바닥 텍스처와 디테일 텍스처 결합
		textureColor = textureColor * detailColor * detailBrightness;
	}

	// 모든 픽셀에 대해 기본 출력 색상을 주변 광원 값으로 설정
	color = ambientColor;
	*/
}